## R script of the high performance computing exercises.
#####################################################################
############# REQUIRED PACKAGES #####################################
#####################################################################

rm(list=ls())
graphics.off()
require(ggplot2)
library(lattice)
require(plyr)
require(reshape2)
######################################################################
############# REQUIRED FUNCTIONS #####################################
######################################################################
community <- c(1,2,3,4,5,6,7,8)
## Function to count the number of species in a commnunity (stored as a vector)
species_richness <- function(x){
  num <- length(unique(x))
  return(num)
}
species_richness(community)

## Function to create a list of minimal vector containing all the elements for the ecosystem.
initialise_max <- function(y){
 sequence <- seq(from = 1, to = y, by = 1)
 return(sequence)
}

## Function to create a random list of a specific size with a maximum number of species, initialising a random species distribution.
initialise_randm <- function(size = 100, species = 50){
  sequence <- seq(from = 1, to = species, by = 1)
  out <- c(sequence,sample(species,size-length(sequence),replace=TRUE))
  return(out)
}
## Returns system (as vector) of minimum number of species for the size of the system.
initialise_min <- function(z){
  min <- rep(1,z)
  return(min)
}

## Return a community after a single time step, altering one species to another.
neutral_step <- function(x1){
  len <- length(x1)
  pos <- sample(1:len, 2, replace = FALSE)
  x1[pos[1]] <- x1[pos[2]]
  return(x1)
}
# neutral_step(community)


## Neutral time series
neutral_time_series <- function(initial = community, duration = 5, interval = 1){
  output <- list()
  i <- 0
  spec_rich <- species_richness(initial)
  while(i < duration){
    initial <- c(neutral_step(initial))
    time <- i%/%interval
    spec_rich[time + 2] <- species_richness(initial)
    i <- i + 1
  }
  output <- list(spec_rich, initial)
  return(output)
  }


## Plotting speciation of 100 species over 10,000 time steps
question_6 <- function(){
  comm <- initialise_max(100)
  spec_r <- neutral_time_series(comm,10000,10)[1]
  time <- seq(from = 0, to = 10000, by = 10)
  frame <- data.frame(spec_r,time)
  names(frame) <- c("Species", "Time")
  p <- ggplot(data = frame, aes(x = Time, y = Species), xlab = "Time-steps", ylab = "Species richness") +
    geom_line(colour = "darkblue", size = 1.5) + theme_bw()
  p
  pdf("../Results/question_6.pdf") #writes output to a pdf
  print(p)
  dev.off()
}
question_6()

## Including speciation


neutral_step_speciation <- function(x1, v){
  len <- length(x1)
  pos <- sample(1:len, 2, replace = FALSE)
  if(runif(1,0,1) < v){
    x1[pos[1]] <- max(x1) + 1
    return(x1)
  }
  else{
    x1[pos[1]] <- x1[pos[2]]
    return(x1)
  }
}
neutral_time_series_speciation <- function(initial = community, duration = 5, interval = 1, v = 0.2){
  output <- list()
  i <- 0
  spec_rich <- species_richness(initial)
  while(i < duration){
    initial <- c(neutral_step_speciation(initial, v))
    time <- i%/%interval
    spec_rich[time + 2] <- species_richness(initial)
    i <- i + 1
  }
  output <- list(spec_rich, initial)
  return(output)
}

###########################################################################
############# QUESTIONS AND CHALLENGES ####################################
###########################################################################

# QUESTION 9 

question_9 <- function(){
  comm1 <- initialise_max(100)
  comm2 <- initialise_min(100)
  spec_r1 <- neutral_time_series_speciation(comm1,10000,10,0.1)[1]
  spec_r2 <- neutral_time_series_speciation(comm2,10000,10,0.1)[1]
  time <- seq(from = 0, to = 10000, by = 10)
  frame1 <- data.frame("Spec1",spec_r1,time)
  frame2 <- data.frame("Spec2",spec_r2,time)
  names(frame1) <- c("Spec","Time","Specrich")
  names(frame2) <- c("Spec","Time","Specrich")
  frame <- rbind(frame1, frame2)
  names(frame) <- c("Specrich", "Spec", "Time")
  p1 <- ggplot() + xlab("Time-steps") + ylab("Species richness") +
    geom_line(data = frame, aes(x = Time, y = Spec, colour = Specrich), size = 1) +
    scale_colour_manual(name  ="Initial Conditions",
                        values = c("red","blue"),
                         labels=c("100 Initial Species", "1 Initial Species")) +
    theme_bw()
  pdf("../Results/question_9.pdf", 7.8, 5.7)
  print(p1)
  dev.off()
}

## Sorts species abundance
species_abundance <- function(c){
  y <- as.data.frame(table(c))
  x <- c(y[2])
  z <- sort(x$Freq, decreasing = TRUE)
  return(z)
}

## Counts the number of values which are within a power of 2
octaves <- function(o){
  x <- log(o, base = 2)
  y <- floor(x) + 1
  y <- as.data.frame(tabulate(y))
  y <- c(y[1])
  return(y$tabulate)
}

## Adds two vectors, placing zeros in elements of smaller vector
sum_vect <- function(x, y){
  x_l <- length(x)
  y_l <- length(y)
  if(x_l > y_l){
    a <- x
    b = y}
  else{ a = y
        b = x}
  c <- length(a) - length(b)
  b <- c(b,rep(0, times = c))
  d <- a + b
  return(d)
}

# QUESTION 13

question_13 <- function(){
  # Initialise starting conditions.
  comm1 <- initialise_max(100)
  comm2 <- initialise_min(100)
  # Perform first time-step.
  spec_r1 <- neutral_time_series_speciation(comm1,10000,10,0.1)
  spec_r2 <- neutral_time_series_speciation(spec_r1[2][[1]],1000,10,0.1)
  # Write data as octaves to matrix
  out1 <- octaves(species_abundance(spec_r1[2]))
  out2 <- octaves(species_abundance(spec_r2[2][[1]]))
  # Loop through increasing number of iterations
  i <- 0
  output <- list(out1, out2)
  output2 <- sum_vect(out1, c(0))
  while(i < 100){
    spec_r2 <- neutral_time_series_speciation(spec_r2[2][[1]],1000,10,0.1)
    out2 <- octaves(species_abundance(spec_r2[2][[1]]))
    output <- append(output, list(out2))
    output2 <- sum_vect(output2,out2)
    i <- i + 1
  }
  naming <- c("2^0","2^1","2^2","2^3","2^4","2^5")
  output3 <- data.frame(naming, output2/102)
  p <- ggplot(data = output3, aes(x = naming, y = output2.102)) + 
    geom_bar(stat = "identity") + 
    xlab("Average species abundance (octave category)") + 
    ylab("Average number of species")+ 
    theme(legend.position = "none") +
    theme_bw()
  p
  pdf("../Results/question_13.pdf", 7,7)
  print(p)
  dev.off()
}

# CHALLENGE A

challenge_A <- function(){
  ## High initial values
  spec_r1_initial <- initialise_max(100)
  spec_r2 <- neutral_time_series_speciation(spec_r1_initial,10000,10,0.1)
  data1 <- data.frame(spec_r2[[1]])
  names(data1) <- c(1)
  comm2 <- initialise_min(100)
  i <- 0
  while(i < 100){
    spec_r1 <- neutral_time_series_speciation(spec_r1_initial,10000,10,0.1)
    spec_r2 <- spec_r1[[1]]
    x <- names(data1)
    data1 <- data.frame(data1, spec_r2)
    names(data1) <- c(x,i)
    i <- i + 1
  }
  se <- function(x){
    conf <- qnorm(0.99,sqrt(var(x)/length(x)))
    conf
  }
  data2 <- data.frame(apply(data1,1, se))
  names(data2) = "SE"
  data3 <- data.frame(apply(data1, 1, mean))
  names(data3) = "Mean"
  seq <- seq(from = 0, to = 10000, by = 10)
  data1 <- data.frame(data1, data2, data3, seq)
  low <- data1$Mean - data1$SE
  upp <- data1$Mean + data1$SE
  data1 <- data.frame(data1, low, upp)
  ## Low initial value
  spec_r11_initial <- initialise_min(100)
  spec_r21 <- neutral_time_series_speciation(spec_r11_initial,10000,10,0.1)
  data11 <- data.frame(spec_r21[[1]])
  names(data11) <- c(1)
  i <- 0
  while(i < 100){
    spec_r11 <- neutral_time_series_speciation(spec_r11_initial,10000,10,0.1)
    spec_r12 <- spec_r11[[1]]
    x1 <- names(data11)
    data11 <- data.frame(data11, spec_r12)
    names(data11) <- c(x1,i)
    i <- i + 1
  }
  data21 <- data.frame(apply(data11,1, se))
  names(data21) = "SE"
  data31 <- data.frame(apply(data11, 1, mean))
  names(data31) = "Mean"
  data11 <- data.frame(data11, data21, data31, seq)
  low1 <- data11$Mean - data11$SE
  upp1 <- data11$Mean + data11$SE
  data11 <- data.frame(data11, low1, upp1)
  names(data11) <- names(data1)
  graph_data <- rbind(data.frame(c(data1,Range="high")),data.frame(c(data11,Range="low")))
  p <- ggplot(data = graph_data, aes(x = seq)) +
    geom_ribbon(mapping = aes(ymin = low, ymax = upp, fill = Range),alpha = 0.5) +
    geom_line(aes(y = Mean, colour = Range)) + 
    scale_fill_manual(name = "99.9% confidence interval", labels = c("High initial value", "Low initial value"),values = c("red","red4"))+
    scale_colour_manual(name = "Average number of species", labels = c("High initial value", "Low initial value"),values = c("plum2","papayawhip"))+
    xlab("Number of iterations") + 
    ylab("Number of species") +
    theme_bw()
  pdf("../Results/challenge_A.pdf",10,8)
  print(p)
  dev.off()
}

# CHALLENGE B

challenge_B <- function(){
  output <- data.frame()
  j <- 0
  while(j < 101){
  i <- 0
  ## Initialise random vector
  spec_r1_initial <- initialise_randm(100,max(j,1))
  spec_r2 <- neutral_time_series_speciation(spec_r1_initial,10000,10,0.1)
  data1 <- data.frame(spec_r2[[1]])
  names(data1) <- c(1)
  while(i < 10){
    spec_r1 <- neutral_time_series_speciation(spec_r1_initial,10000,10,0.1)
    spec_r2 <- spec_r1[[1]]
    x <- names(data1)
    data1 <- data.frame(data1, spec_r2)
    names(data1) <- c(x,i)
    i <- i + 1
  }
  output <- rbind(output,data.frame(c(data1,Iter = data1[1,1])))
  j<- j + 10
  }
  output2 <- data.frame(output,apply(output[,0:11],1,mean))
  output2 <- data.frame(output2, seq(0,1000,1))
  names(output2) <- c(names(output),"Mean","Generation")
  p <- ggplot(data = output2,aes(x = Generation, y=Mean,colour=factor(Iter))) +
    geom_line(alpha=0.4) + 
    scale_colour_discrete(name = "Initial number of species")+
    xlab("Number of iterations") + 
    ylab("Number of species") +
    theme_bw()
  pdf("../Results/challenge_B.pdf",8,6)
  print(p)
  dev.off()
}


### SPECIATION RATE 0.005403

# Multiple plot function
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  require(grid)
  
  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)
  
  numPlots = length(plots)
  
  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                     ncol = cols, nrow = ceiling(numPlots/cols))
  }
  
  if (numPlots==1) {
    print(plots[[1]])
    
  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
    
    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
      
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}

######################################################################
################ HPC SIMULATIONS #####################################
######################################################################
# set 
iter <- 1 #as.numeric(Sys.getenv("PBS_ARRAY_INDEX"))

# REQUIRED FUNCTIONS


J <- iter%%4
ser <- c(500, 1000, 2500, 5000)
sr <- ser[J+1]
io <- sr/10

# MAIN FUNCTION
cluster_run <- function(speciation_rate = 0.001, size = 100, wall_time = 2, rand_seed = 1, interval_rich = 10, interval_oct = 10, burn_in_time = 2) {
  int_time <- proc.time()[[3]]
  seconds <- proc.time()[[3]] + (wall_time * 60)
  set.seed(rand_seed)
  comm2 = initialise_max(size)
  ### Burn in period
  neutral_gen <- function(data){
    data2 <- neutral_time_series_speciation(data,size, size, speciation_rate)
    data2
  }
  spec_r1 <- neutral_gen(comm2)
  spec_r2 <- spec_r1
  out1 <- octaves(species_abundance(spec_r1[2]))
  rich_out <- spec_r1[[1]]
  oct_out <- list(out1)
  i <- 1
  burn_tot <- 4 * size
  while(i < burn_tot-1){
    spec_r2 <- neutral_gen(spec_r2[2][[1]])
    rich_out <- c(rich_out, spec_r2[[1]])
    gen_count <- i%%interval_oct
    if(gen_count == 0){
      out2 <- octaves(species_abundance(spec_r2[2][[1]]))
      oct_out <- append(oct_out, list(out2))
    }
    i <- i + 1
    
  }
  i <- 0
  int_gen <- size*size/10
  while(proc.time()[[3]] < seconds){
    spec_r2 <- neutral_time_series_speciation(spec_r2[2][[1]],int_gen,100,speciation_rate)
    out2 <- octaves(species_abundance(spec_r2[2][[1]]))
    oct_out <- append(oct_out, list(out2))
    spec_r3 <- spec_r2[[2]]
  }
  tot_time <- proc.time()[[3]] - int_time
  save( rich_out, oct_out, size, speciation_rate, wall_time, rand_seed, interval_rich, interval_oct, burn_in_time, tot_time, spec_r3, file = paste(sep = "","HPC",iter,".Rdata"))
  print("Species richness of burn in time period:")
  print(rich_out)
  print("Species abundance as octaves for each generation:")
  print(oct_out)
  print("Final species distribution:")
  print(spec_r3)
} 
# Test cluster code
#cluster_run(0.005403, size = sr, wall_time = 6, rand_seed = iter, interval_rich = 1, interval_oct = io, burn_in_time = 1)
### Cluster Code  to run###
### cluster_run(0.005403, size = sr, wall_time = 690, rand_seed = iter, interval_rich = 1, interval_oct = io, burn_in_time = 4)
##########################################################
############# START OF MAIN ANALYSIS   ###################
##########################################################
# QUESTION 16
# Performs analysis on each file and plots the graph as two separate functions for ease (analyse() and calc_means())
setwd("../Results")
file_names <- as.list(dir(pattern = "*.Rdata"))
oct_means1 <- data.frame(matrix(NA,1,14))
names(oct_means1) <- c("V1","V2","V3","V4","V5","V6","V7","V8","V9","V10","V11","V12","V13","V14")
oct_means2 <- data.frame(matrix(NA,1,14))
names(oct_means2) <- c("V1","V2","V3","V4","V5","V6","V7","V8","V9","V10","V11","V12","V13","V14")
oct_means3 <- data.frame(matrix(NA,1,14))
names(oct_means3) <- c("V1","V2","V3","V4","V5","V6","V7","V8","V9","V10","V11","V12","V13","V14")
oct_means4 <- data.frame(matrix(NA,1,14))
names(oct_means4) <- c("V1","V2","V3","V4","V5","V6","V7","V8","V9","V10","V11","V12","V13","V14")
num2 <- c(0:13)
# Goes through each output file and performs the required calculations. Outputs octaves which can then be plotted.
analyse <- function(){
  i <- 1
  for(i in 1:length(file_names)){
    load(file_names[[i]][1])
    nth <- (rand_seed%%4) + 1
    burn <- burn_in_time + 1
    lgh <- length(oct_out)
    oct_list <- lapply(oct_out,function(x) c(x,rep(0, 14 - length(x))))
    oct_df <- as.data.frame(matrix(unlist(oct_list),ncol=14,byrow=T))
    #   oct_df <- data.frame(Reduce(rbind, oct_list))
    oct_df <- oct_df[burn:(length(oct_out)),]
    if(nth == 1){
      oct_means1 <<- rbind(oct_means1, oct_df)
    }
    if(nth == 2){
      oct_means2 <<- rbind(oct_means2, oct_df)
    }
    if(nth == 3){
      oct_means3 <<- rbind(oct_means3, oct_df)
    }
    if(nth == 4){
      oct_means4 <<- rbind(oct_means4, oct_df)
    }
    print(i)
    i <- i + 1
  }
}

calc_means <- function(){
  oct_means1 <- oct_means1[2:nrow(oct_means1),]
  oct_means2 <- oct_means2[2:nrow(oct_means2),]
  oct_means3 <- oct_means3[2:nrow(oct_means3),]
  oct_means4 <- oct_means4[2:nrow(oct_means4),]
  oct_means1_tot <- c(colMeans(oct_means1))
  oct_means1_tot <- data.frame(oct_means1_tot, num2)
  names(oct_means1_tot) <- c("Mean", "Tot")
  oct_means2_tot <- c(colMeans(oct_means2))
  oct_means2_tot <- data.frame(oct_means2_tot, num2)
  names(oct_means2_tot) <- c("Mean", "Tot")
  oct_means3_tot <- c(colMeans(oct_means3))
  oct_means3_tot <- data.frame(oct_means3_tot, num2)
  names(oct_means3_tot) <- c("Mean", "Tot")
  oct_means4_tot <- c(colMeans(oct_means4))
  oct_means4_tot <- data.frame(oct_means4_tot, num2)
  names(oct_means4_tot) <- c("Mean", "Tot")
  out <- data.frame(oct_means1_tot$Mean, oct_means2_tot$Mean,oct_means3_tot$Mean,oct_means4_tot$Mean)
  names(out) <- c(500,1000,2500,5000)
  out <- data.frame(t(out))
  out <- out[,1:12]
  names(out) <- c("1 Species","2-3 Species","4-7 Species","8-15 Species","16-31 Species","32-63 Species","64-127 Species", "128-255 Species","256-511 Species","512-1023 Species","1024-2047 Species","2048-5095 Species")
  write.csv(out,"HPC_octaves.csv", row.names=TRUE)
  par(mfrow=c(2,2))
  p1 <- ggplot(data = oct_means1_tot, aes(y = Mean, x = Tot)) +
    geom_bar(stat = "identity", fill = "red4")+
    labs(title="Mean Species Abundance in Octaves for Sample Size of 500") + 
    ylab("Average number of species") + 
    xlab("Octave category (2^n)") +
    scale_x_continuous(breaks=c(seq(0,13,1))) + 
    theme_bw()
  p2 <- ggplot(data = oct_means2_tot, aes(y = Mean, x = Tot)) +
    geom_bar(stat = "identity", fill = "red4")+
    labs(title="Mean Species Abundance in Octaves for Sample Size of 1000") + 
    ylab("Average number of species") + 
    xlab("Octave category (2^n)") +
    scale_x_continuous(breaks=c(seq(0,13,1))) + 
    theme_bw()
  p3 <- ggplot(data = oct_means3_tot, aes(y = Mean, x = Tot)) +
    geom_bar(stat = "identity", fill = "red4")+
    labs(title="Mean Species Abundance in Octaves for Sample Size of 2500") + 
    ylab("Average number of species") + 
    xlab("Octave category (2^n)") +
    scale_x_continuous(breaks=c(seq(0,13,1))) + 
    theme_bw()
  p4 <- ggplot(data = oct_means4_tot, aes(y = Mean, x = Tot)) +
    geom_bar(stat = "identity", fill = "red4")+
    labs(title="Mean Species Abundance in Octaves for Sample Size of 5000") + 
    ylab("Average number of species") + 
    xlab("Octave category (2^n)") +
    scale_x_continuous(breaks=c(seq(0,13,1))) + 
    theme_bw()
  pdf("../Results/HPC_octaves.pdf", 14, 14)
  multiplot(p1,p2,p3,p4,cols = 2)
  dev.off()
}
# Perform Analysis
# analyse()
# calc_means()
##############################################################################
################ HPC CHALLENGE QUESTIONS #####################################
##############################################################################

# CHALLENGE C

challenge_C <- function(){
  #Initialise data empty data frames for each population size
  rich_means1 <- data.frame(rep(NA,3998))
  rich_means2 <- data.frame(rep(NA,7998))
  rich_means3 <- data.frame(rep(NA,19998))
  rich_means4 <- data.frame(rep(NA,39998))
  # Initialise starting values
  i <- 1
  n1 <- 1
  n2 <- 1
  n3 <- 1
  n4 <- 1
  # Loop through files and add relevent data into relevent data frame
  for(i in 1:length(file_names)){
    load(file_names[[i]][1])
    nth <- (rand_seed%%4) + 1
    if(nth == 1){
      rich_means1 <- data.frame(rich_means1, rich_out)
      n1 <- n1 + 1
    }
    if(nth == 2){
      rich_means2 <- data.frame(rich_means2, rich_out)
      n2 <- n2 + 1
    }
    if(nth == 3){
      rich_means3 <- data.frame(rich_means3, rich_out)
      n3 <- n3 + 1
    }
    if(nth == 4){
      rich_means4 <- data.frame(rich_means4, rich_out)
      n4 <- n4 + 1
    }
    i <- i + 1
  }
  # Manipulate data frames into the correct format
  rich_means1 <- rich_means1[,2:n1]
  rich_means1 <- rich_means1[seq(1,NROW(rich_means1),by = 2),]
  rich_means2 <- rich_means2[,2:n2]
  rich_means2 <- rich_means2[seq(1,NROW(rich_means2),by = 2),]
  rich_means3 <- rich_means3[,2:n3]
  rich_means3 <- rich_means3[seq(1,NROW(rich_means3),by = 2),]
  rich_means4 <- rich_means4[,2:n4]
  rich_means4 <- rich_means4[seq(1,NROW(rich_means4),by = 2),]
  rich1 <<-data.frame(rowMeans(rich_means1),seq(0,1998,1))
  names(rich1) <- c("Mean","Gen")
  rich2 <<-data.frame(rowMeans(rich_means2),seq(0,3998,1))
  names(rich2) <- c("Mean","Gen")
  rich3 <<-data.frame(rowMeans(rich_means3),seq(0,9998,1))
  names(rich3) <- c("Mean","Gen")
  rich4 <<-data.frame(rowMeans(rich_means4),seq(0,19998,1))
  names(rich4) <- c("Mean","Gen")
  # Plot data in ggplot
  p1 <- ggplot(data = rich1, aes(y = Mean, x = Gen)) +
    geom_line() +
    labs(title="Mean Species Richness for Sample Size of 500") + 
    ylab("Average number of species") + 
    xlab("Generation")+
    theme_bw()
  p2 <- ggplot(data = rich2, aes(y = Mean, x = Gen)) +
    geom_line() +
    labs(title="Mean Species Richness for Sample Size of 1000") + 
    ylab("Average number of species") + 
    xlab("Generation")+
    theme_bw()
  p3 <- ggplot(data = rich3, aes(y = Mean, x = Gen)) +
    geom_line() +
    labs(title="Mean Species Richness for Sample Size of 2500") + 
    ylab("Average number of species") + 
    xlab("Generation")+
    theme_bw()
  p4 <- ggplot(data = rich4, aes(y = Mean, x = Gen)) +
    geom_line() +
    labs(title="Mean Species Richness for Sample Size of 5000") + 
    ylab("Average number of species") + 
    xlab("Generation")+
    theme_bw()
  # Output plots as multi-panel graph to pdf.
  pdf("../Results/challenge_C.pdf", 10, 8)
  multiplot(p1,p2,p3,p4,cols = 2)
  dev.off()
}
# CHALLENGE D - COALESCENCE
J <- 100
v <- 0.1
# Runs the coalescence function to produce octave classes for the state at equilibrium.
challenge_D <- function(J = size, v = speciation_rate){
  lineages <- rep(1,J)
  N <- J
  abundances <-c()
  sigma <- v*(N-1)/(1-v)
  while(N>1){
    j <- sample(1:N,1)
    randnum <- runif(1,0,1)
    p_val <- sigma/(sigma + N -1)
    if(randnum<p_val){
      abundances <- append(abundances, lineages[j])
    } else{
      seqn <- seq(1, N,1)
      i <- sample(seqn[seqn != j],1)
      lineages[i] <- lineages[i] + lineages[j]
    }
      lineages <- lineages[-j]
      N <- N - 1
    
  }
  abundances <- append(abundances, lineages[1])
  return(abundances)
}

# Function that completes multiple runs of the coalescence function for each population size, 
# and then averages out the repeated runs to produce an average of octave classes that should be close to the real value.

challenge_D_multiple <- function(N){
  sr <- 0.005403
  i <- 1
  res <- matrix(,nrow = N,ncol=12)
  while(i < N+1){
    out <- octaves(challenge_D(500,sr))
    res[i,] <- c(out,rep(0,(12-length(out))))
    i <- i+1
  }
  i <- 1
  res2 <- matrix(,nrow = N,ncol=12)
  while(i < N+1){
    out <- octaves(challenge_D(1000,sr))
    res2[i,] <- c(out,rep(0,(12-length(out))))
    i <- i+1
  }
  i <- 1
  res4 <- matrix(,nrow = N,ncol=12)
  while(i < N+1){
    out <- octaves(challenge_D(5000,sr))
    res4[i,] <- c(out,rep(0,(12-length(out))))
    i <- i+1
  }
  i <- 1
  res3 <- matrix(,nrow = N,ncol=12)
  while(i < N+1){
    out <- octaves(challenge_D(2500,sr))
    res3[i,] <- c(out,rep(0,(12-length(out))))
    i <- i+1
  }
  output <- matrix(c(colMeans(res),colMeans(res2),colMeans(res3),colMeans(res4)),ncol=12,byrow=T)
  print(output)
  write_out<- data.frame(output)
  names(write_out) <- c("1 Species","2-3 Species","4-7 Species","8-15 Species","16-31 Species","32-63 Species","64-127 Species", "128-255 Species","256-511 Species","512-1023 Species","1024-2047 Species","2048-5095 Species")
  write.csv(write_out,"HPC_coalescence.csv", row.names=TRUE)
  oct_means1_tot <- data.frame(output[1,],seq(1,12,1))
  names(oct_means1_tot) <- c("Mean","Tot")
  oct_means2_tot <- data.frame(output[2,],seq(1,12,1))
  names(oct_means2_tot) <- c("Mean","Tot")
  oct_means3_tot <- data.frame(output[3,],seq(1,12,1))
  names(oct_means3_tot) <- c("Mean","Tot")
  oct_means4_tot <- data.frame(output[4,],seq(1,12,1))
  names(oct_means4_tot) <- c("Mean","Tot")
  p1 <- ggplot(data = oct_means1_tot, aes(y = Mean, x = Tot)) +
    geom_bar(stat = "identity", fill = "red4")+
    labs(title="Mean Species Abundance in Octaves for Sample Size of 500") + 
    ylab("Average number of species") + 
    xlab("Octave category (2^n)") +
    scale_x_continuous(breaks=c(seq(0,13,1))) + 
    theme_bw()
  p2 <- ggplot(data = oct_means2_tot, aes(y = Mean, x = Tot)) +
    geom_bar(stat = "identity", fill = "red4")+
    labs(title="Mean Species Abundance in Octaves for Sample Size of 1000") + 
    ylab("Average number of species") + 
    xlab("Octave category (2^n)") +
    scale_x_continuous(breaks=c(seq(0,13,1))) + 
    theme_bw()
  p3 <- ggplot(data = oct_means3_tot, aes(y = Mean, x = Tot)) +
    geom_bar(stat = "identity", fill = "red4")+
    labs(title="Mean Species Abundance in Octaves for Sample Size of 2500") + 
    ylab("Average number of species") + 
    xlab("Octave category (2^n)") +
    scale_x_continuous(breaks=c(seq(0,13,1))) + 
    theme_bw()
  p4 <- ggplot(data = oct_means4_tot, aes(y = Mean, x = Tot)) +
    geom_bar(stat = "identity", fill = "red4")+
    labs(title="Mean Species Abundance in Octaves for Sample Size of 5000") + 
    ylab("Average number of species") + 
    xlab("Octave category (2^n)") +
    scale_x_continuous(breaks=c(seq(0,13,1))) + 
    theme_bw()
  pdf("../Results/HPC_coalescence.pdf", 14, 14)
  multiplot(p1,p2,p3,p4,cols = 2)
  dev.off()
}
challenge_D_multiple(100)

##############################################################################
################### CHAOS AND FRACTAL QUESTIONS ##############################
##############################################################################
# QUESTION 18 - Chaos Game
# Draws lines between points
# Changing initial conditions causes the line to be drawn outside of the triangle of convergence,
# but tending towards the triangle. Eventually, it is within th triangle, at which point it will never leave.

chaos_game <- function(N){
# Initialise boundary points, plot and initial X coordinates.
a = c(0,0)
b = c(3,4)
c = c(4,1)
plot(0,0,type = "b",xlim=c(0,4),ylim =c(0,4),ylab="y",xlab="x",cex=0.1,axes=FALSE,ann=FALSE)
x <- 4
y <- 3
i<-1
p <- list(a,b,c)
# Loop over N times, drawing a line each time half way towards a random point.
while(i<N){
  new <- sample(p,1)[[1]]
  x_new <- 0.5*(new[1]-x)
  y_new <- 0.5*(new[2] - y)
  x <- c(x,x+x_new)
  y <- c(y,y+y_new)
  points(x,y, type = "p",cex=0.1)
  x <- x[2]
  y <- y[2]
  i <- i + 1
}

}

# CHALLENGE E

challenge_E <- function(N){
  # Initialise boundary points, plot and initial X coordinates.
  a = c(0,0)
  b = c(3,4)
  c = c(4,1)
  plot(0,0,type = "b",xlim=c(0,4),ylim =c(0,4),ylab="y",xlab="x",cex=0.1)
  x <- 0
  y <- 0
  i<-1
  p <- list(a,b,c)
  cl <- rainbow(N)
  # Loop over N times, drawing a line each time half way towards a random point.
  while(i<N){
    new <- sample(p,1)[[1]]
    x_new <- 0.5*(new[1]-x)
    y_new <- 0.5*(new[2] - y)
    x <- c(x,x+x_new)
    y <- c(y,y+y_new)
    points(x,y, type = "p",col = cl[i],cex=0.1)
    x <- x[2]
    y <- y[2]
    i <- i + 1
  }
  
}

# Draws a sierpenski gasket on an equilateral triangle.

sierpenski_gasket <- function(N){
  # Initialise boundary points, plot and initial X coordinates.
  a = c(0,0)
  b = c(4,0)
  c = c(2,sqrt(12))
  plot(0,0,type = "b",xlim=c(0,4),ylim =c(0,4),ylab="y",xlab="x",cex=0.02,axes=FALSE,ann=FALSE)
  x <- 2
  y <- 1
  i<-1
  p <- list(a,b,c)
  cl <- rainbow(N)
  # Loop over N times, drawing a line each time half way towards a random point.
  while(i<N){
    new <- sample(p,1)[[1]]
    x_new <- 0.5*(new[1]-x)
    y_new <- 0.5*(new[2] - y)
    x <- c(x,x+x_new)
    y <- c(y,y+y_new)
    points(x,y, type = "p",col = cl[i],cex=0.02)
    x <- x[2]
    y <- y[2]
    i <- i + 1
  }
}

# QUESTION 19

turtle <- function(start,direction,length){
  # Define new x and y coordinates
  x <- start[1] + length*cos(direction)
  y <- start[2] + length*sin(direction)
  # Draw a line between old and new coordinates
  lines(c(start[1],x),c(start[2],y),type="l")
  return(c(x,y))
}

# Runs the turtle function by initiating the plot

run_turtle <- function(start,direction,length){
  plot(0,0,type="b",cex=0.1,xlim=c(-10,10),ylim=c(-10,10),axes=FALSE,ann=FALSE)
  turtle(start,direction,length)
}
# run_turtle(c(2,1),23*pi/4,2)

# QUESTION 20

elbow <- function(start,direction,length){
  out <- turtle(start,direction,length)
  x <- out[1] + 0.95*length*cos(direction - (pi/4))
  y <- out[2] + 0.95*length*sin(direction - (pi/4))
  lines(c(start[1],x),c(start[2],y),type="l")
  return(c(x,y))
}

# Runs the elbow function on an empty plot

run_elbow <- function(start,direction,length){
  plot(start[1],start[1],type="b",cex=0.1,xlim=c(-10,10),ylim=c(-10,10),axes=FALSE,ann=FALSE)
  elbow(start,direction,length)
}
# run_elbow(c(2,1),23*pi/4,2)

# QUESTION 21 - Spiral function (this function crashes R)

spiral <- function(start,direction,length){
  # Find next coordinates
  out <- turtle(start,direction,length)
  # Plot line between start point and next point.
  turtle(start,direction,length)
  # Loop over spiral again with the end point of out becoming the start point for the next spiral iteration
  spiral(out,direction-(pi/4),0.95*length)
  }

# QUESTION 22 - Spiral 2 function (works in R)

spiral2 <- function(start,direction,length){
  # Find next coordinates
  out <- turtle(start,direction,length)
  # Plot line between start point and next point.
  turtle(start,direction,length)
  # Stop the iterations if the size of the length is extremely small.
  # Otherwise loop over spiral2 again with the end point of out becoming the start point for the next spiral iteration
  if(length>0.01){
    spiral2(out,direction-(pi/4),0.95*length)
    #return(c(x,y))
  }
}

# Runs the spiral functions
run_spiral <- function(start,direction,length){
plot(start[1],start[2],type="b",cex=0.1,xlim=c(-5,5),ylim=c(-5,5),axes=FALSE,ann=FALSE)
spiral(start,direction,length)
}
run_spiral2 <- function(start,direction,length){
  plot(start[1],start[2],type="b",cex=0.1,xlim=c(-5,5),ylim=c(-5,5),axes=FALSE,ann=FALSE)
  spiral2(start,direction,length)
}

# run_spiral(c(-3,2),pi/4,2) # Produces infinite recursion error
# run_spiral2(c(-3,2),pi/4,2) # Works without the error

# QUESTION 23 - Tree

# turtle function with an added colour parameter that colours the line.
turtle_col <- function(start,direction,length,colour,w){
  # Define new x and y coordinates
  x <- start[1] + length*cos(direction)
  y <- start[2] + length*sin(direction)
  # Draw a line between old and new coordinates
  lines(c(start[1],x),c(start[2],y),type="l",col=colour,lwd=w)
  return(c(x,y))
}

run_turtle_col <- function(start,direction,length,colour,w){
  plot(0,0,type="b",cex=0.1,xlim=c(-10,10),ylim=c(-10,10),axes=FALSE,ann=FALSE)
  turtle_col(start,direction,length,colour,w)
}

# run_turtle_col(c(-3,2),pi/4,2,"green3",3)

tree <- function(start,direction,length){
  # Find coordinates of end point of the line.
  out <- turtle(start,direction,length)
  # Start by drawing a line from the start to the next point
  # Stop the iterations if the size of the length is extremely small.
  # Otherwise loop over the tree, plotting two lines at (pi/4) rotations to the left and right of the original line and 0.65 times the length.
  if(length>0.05){
    tree(out,direction-(pi/4),0.65*length)
    tree(out,direction+(pi/4),0.65*length)
  }
}

pretty_tree <- function(start,direction,length,w){
  # Find coordinates of end point of the line.
  out <- turtle_col(start,direction,length,shade[1],w*10*length)
  # Define the colour of the next line. This is done by choosing the colour from the vector shade based on the length of the line.
  col <- shade[min(round(-min(log(length),-1)),6)]
  # Start by drawing a line from the start to the next point
  turtle_col(start,direction,length,col,w*10*length)
  # Stop the iterations if the size of the length is extremely small.
  # Otherwise loop over the tree, plotting two lines at (pi/4) rotations to the left and right of the original line and 0.65 times the length.
  if(length>0.03){
    pretty_tree(out,direction-(pi/4),0.65*length,w)
    pretty_tree(out,direction+(pi/4),0.65*length,w)
  }
}
# Runs the tree function on a plot

run_tree <- function(start,direction,length){
  plot(start[1],start[2],type="b",cex=0.1,xlim=c(-5,5),ylim=c(-5,5),axes=FALSE,ann=FALSE)
  tree(start,direction,length)
}
# run_tree(c(0,-4),pi/2,2)

# Runs the pretty tree function on a plot
run_pretty_tree <- function(start,direction,length,w){
  # Defines the range of colours to take
  shade <<- c("#663300","#006600","#009900","#00CC00","#00FF00","#33FF33")
  plot(start[1],start[2],type="b",cex=0.1,xlim=c(-5,5),ylim=c(-5,5),axes=FALSE,ann=FALSE)
  pretty_tree(start,direction,length,w)
}
# run_pretty_tree(c(0,-4),pi/2,2,1)

# QUESTION 24 - Fern

fern <- function(start,direction,length){
  # Find coordinates of end point of the line.
  out <- turtle(start,direction,length)
  # Start by drawing a line from the start to the next point
  turtle_col(start,direction,length,"green3",10*length)
  # Stop the iterations if the size of the length is extremely small.
  # Otherwise loop over the fern, plotting two lines, one straight up and 0.87 times the length
                                                    # the other pi/4 rotation clockwise and 0.38 times the length
  if(length>0.05){
    fern(out,direction-(pi/4),0.38*length)
    fern(out,direction,0.87*length)
  }
}

# Runs the fern function on a plot

run_fern <- function(start,direction,length){
  plot(start[1],start[2],type="b",cex=0.1,xlim=c(-8,8),ylim=c(-5,15),axes=FALSE,ann=FALSE)
  fern(start,direction,length)
}
# run_fern(c(0,-4),pi/2,2)

# QUESTION 25 - Fern 2

fern2 <- function(start,direction,length,dir){
  out <- turtle(start,direction,length)
  turtle_col(start,direction,length,"green3",1)
  # Don't let the function continue looping for very small lengths
  if(length>0.05){
    fern2(out,direction-(dir*(pi/4)),0.38*length,(-dir))
    fern2(out,direction,0.87*length,-dir)
    #return(c(x,y))
  }
}

# Runs the fern2 function on a plot

run_fern2 <- function(start,direction,length,dir){
  plot(start[1],start[2],type="b",cex=0.1,xlim=c(-15,15),ylim=c(-5,30),axes=FALSE,ann=FALSE)
  fern2(start,direction,length,dir)
}


# run_fern2(c(0,-4),pi/2,2,1)

# CHALLENGE F AND EXTRA PLOTS
# Plots a pretty tree with the colour changing towards the edges.
challenge_F1 <- function(){
  run_pretty_tree(c(0,-4),pi/2,2,1)
}

# Baobab plotting function with huge initial branches

baobab <- function(start,direction,length){
  # Define the colour of the next line.
  col <- shade[min(round(-min(log(length),-1)),6)]
  # Find coordinates of end point of the line.
  out <- turtle_col(start,direction,15*length,col,20*length)
  if(length>2){
    length <- length*0.15
  }
  # Start by drawing a line from the start to the next point
  #turtle_col(start,direction,20*length,col,length)
  # Stop the iterations if the size of the length is extremely small.
  # Otherwise loop over the tree, plotting two lines at (pi/4) rotations to the left and right of the original line and 0.65 times the length.
  if(length>0.05){
    baobab(out,direction-(pi/4),0.65*length)
    baobab(out,direction+(pi/4),0.65*length)
  }
}

# Plots a pretty landscape with a large baobab tree, several smaller trees and several ferns.
challenge_F2 <- function(){
  plot(0,0,type="o",xlim=c(-40,40),ylim=c(-5,70),cex=0.1,axes=FALSE,ann=FALSE)
  
  # Draw the savanna floor and the sky
  polygon(x=c(-60,60,60,-60),y=c(40,40,-10,-10),border=NA,col="#FFFACD")
  polygon(x=c(-60,60,60,-60),y=c(80,80,40,40),border=NA,col="#E0FFFF")
  
  shade <<- c("#663300","#006600","#009900","#00CC00","#00FF00","#33FF33")
  #LEFT TREES - starting far away and rendering closer
  pretty_tree(c(-35,35),pi/2,3,0.1)
  pretty_tree(c(-5,38),pi/2,2,0.1)
  pretty_tree(c(-20,35),pi/2,2,0.1)
  pretty_tree(c(-30,20),pi/2,5,0.1)
  pretty_tree(c(-5,25),pi/2,5,0.1)
  pretty_tree(c(-20,10),pi/2,6,0.1)
  pretty_tree(c(-30,-4),pi/2,7,0.1)
  
  # RIGHT TREES - starting far away and rendering closer
  pretty_tree(c(35,35),pi/2,3,0.1)
  pretty_tree(c(8,32),pi/2,2,0.1)
  pretty_tree(c(20,35),pi/2,2,0.1)
  pretty_tree(c(25,25),pi/2,5,0.1)
  pretty_tree(c(20,10),pi/2,6,0.1)
  pretty_tree(c(10,0),pi/2,7,0.1)
  
  shade <<- c("#CD853F","#006600","#009900","#00CC00","#00FF00","#33FF33")
  # The main baobab
  baobab(c(-5,-4),pi/2,4)
  # All the ferns
  fern2(c(-26,-4),3*pi/5,0.5,-1)
  fern2(c(-24,-4),2*pi/5,0.5,-1)
  fern2(c(-22,-4),3*pi/5,0.5,-1)
  fern2(c(-20,-4),3*pi/5,0.5,-1)
  fern2(c(-18,-4),2*pi/5,0.5,-1)
  fern2(c(-16,-4),3*pi/5,0.5,-1)
  fern2(c(-16,-4),2*pi/5,0.5,-1)
  fern2(c(-14,-4),3*pi/5,0.5,-1)
  fern2(c(-12,-4),3*pi/5,0.5,-1)
  fern2(c(-10,-4),2*pi/5,0.5,-1)
  fern2(c(-8,-4),3*pi/5,0.5,-1)
  fern2(c(-8,-4),2*pi/5,0.5,-1)
  fern2(c(-6,-4),3*pi/5,0.5,-1)
  fern2(c(-4,-4),3*pi/5,0.5,-1)
  fern2(c(-2,-4),2*pi/5,0.5,-1)
  fern2(c(0,-4),3*pi/5,0.5,-1)
  fern2(c(0,-4),2*pi/5,0.5,-1)
  fern2(c(-2,-4),3*pi/5,0.5,-1)
  fern2(c(4,-4),3*pi/5,0.5,-1)
  fern2(c(6,-4),2*pi/5,0.5,-1)
  fern2(c(8,-4),3*pi/5,0.5,-1)
  fern2(c(8,-4),2*pi/5,0.5,-1)
  fern2(c(10,-4),3*pi/5,0.5,-1)
  fern2(c(12,-4),3*pi/5,0.5,-1)
  fern2(c(14,-4),2*pi/5,0.5,-1)
  fern2(c(16,-4),3*pi/5,0.5,-1)
  fern2(c(18,-4),2*pi/5,0.5,-1)
  fern2(c(20,-4),3*pi/5,0.5,-1)
  fern2(c(22,-4),3*pi/5,0.5,-1)
  fern2(c(24,-4),2*pi/5,0.5,-1)
  # Draw the savanna front last
  polygon(x=c(-60,60,60,-60),y=c(-4,-4,-10,-10),border=NA,col="#F0E68C")
}

# CHALLENGE G - minimalist approach to coding the fern. Total characters is 209 including spaces.

challenge_G<-function(s,d,l,a){M<-matrix(,,2)
p<-function(s,d,l,a){if(l>0.01){r<-c(s[1]+l*cos(d),s[2]+l*sin(d))
p(r,d,0.87*l,-a)
p(r,d+(a*pi/4),0.38*l,-a)
M<<-rbind(M,s)
}}
p(s,d,l,a)
plot(M,,"l",,,,,,,,F,F)
}
challenge_G(c(0,0),pi/2,1,1)

########################################
# COMPLETES ALL QUESTIONS AND CHALLENGE QUESTIONS
run_all <- function(){
  question_6()
  print("Question 6 complete")
  question_9()
  print("Question 9 complete")
  question_13()
  print("Question 13 complete")
  analyse()
  calc_means()
  challenge_A()
  print("Challenge A complete")
  challenge_B()
  print("Challenge B complete")
  challenge_C()
  print("Challenge C complete")
  challenge_D(500,v = 0.005403)
  print("Challenge D complete")
  challenge_D_multiple(100)
  print("Challenge D Multiple complete")
  pdf("../Results/chaos.pdf",6,10)
  par(mfrow=c(2,1))
  chaos_game(100)
  title(main="A - Chaos Game")
  sierpenski_gasket(1000)
  title(main="B - Sierpenski Gasket")
  dev.off()
  print("Chaos Game complete")
  pdf("../Results/spiral.pdf",6,6)
  run_spiral2(c(-3,2),pi/4,2)
  dev.off()
  print("Spiral 2 complete")
  pdf("../Results/tree.pdf",6,6)
  run_tree(c(0,-4),pi/2,2)
  dev.off()
  print("Tree complete")
  pdf("../Results/fern.pdf",6,6)
  run_fern2(c(0,-4),pi/2,4,-1)
  dev.off()
  print("Fern 2 complete")
  pdf("../Results/challenge_F.pdf",8,10)
  par(mfrow=c(2,1))
  challenge_F1()
  title(main="A - Challenge F1")
  challenge_F2()
  title(main="B - Challenge F2")
  dev.off()
  print("Challenge F complete")
  
}
# Runs all the graphics required for the LaTeX document.
run_all_graphics <- function(){
  graphics.off()
  pdf("../Results/chaos.pdf",6,10)
  par(mfrow=c(2,1))
  chaos_game(100)
  title(main="A - Chaos Game")
  sierpenski_gasket(1000)
  title(main="B - Sierpenski Gasket")
  dev.off()
  pdf("../Results/spiral.pdf",6,6)
  run_spiral2(c(-3,2),pi/4,2)
  dev.off()
  pdf("../Results/tree.pdf",6,6)
  run_tree(c(0,-4),pi/2,2)
  dev.off()
  pdf("../Results/fern.pdf",6,6)
  run_fern2(c(0,-4),pi/2,4,-1)
  dev.off()
  pdf("../Results/challenge_F.pdf",8,10)
  par(mfrow=c(2,1))
  challenge_F1()
  title(main="A - Challenge F1")
  challenge_F2()
  title(main="B - Challenge F2")
  dev.off()
}
